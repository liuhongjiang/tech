<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类: git | 刘洪江的流水帐]]></title>
  <link href="http://liuhongjiang.github.com/tech/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://liuhongjiang.github.com/tech/"/>
  <updated>2015-06-19T09:53:57+08:00</updated>
  <id>http://liuhongjiang.github.com/tech/</id>
  <author>
    <name><![CDATA[刘洪江]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[git crlf]]></title>
    <link href="http://liuhongjiang.github.com/tech/blog/2015/06/05/git-crlf/"/>
    <updated>2015-06-05T11:17:00+08:00</updated>
    <id>http://liuhongjiang.github.com/tech/blog/2015/06/05/git-crlf</id>
    <content type="html"><![CDATA[<p>跨平台的情况下，windows和unix的换行符谁不一样的。这个和git结合起来的时候有点烦哈。</p>

<h2 id="gitcrlflf">如何将git的所有crlf文件转换成lf格式</h2>

<p><a href="http://stackoverflow.com/questions/1510798/trying-to-fix-line-endings-with-git-filter-branch-but-having-no-luck/1511273#1511273">将git库中的crlf转换为lf</a></p>

<p>下面这个脚本可以将库中的所有文件中的crlf去掉
<!--more--></p>

<p>```
# From the root of your repository remove everything from the index
git rm –cached -r .</p>

<h1 id="change-the-autocrlf-setting-of-the-repository-you-may-want">Change the autocrlf setting of the repository (you may want</h1>
<p>#  to use true on windows):
git config core.autocrlf input</p>

<h1 id="re-add-all-the-deleted-files-to-the-index">Re-add all the deleted files to the index</h1>
<p># (You should get lots of messages like:
#   warning: CRLF will be replaced by LF in <file>.)
git diff --cached --name-only -z | xargs -0 git add</file></p>

<h1 id="commit">Commit</h1>
<p>git commit -m “Fixed crlf issue”</p>

<h1 id="if-youre-doing-this-on-a-unixmac-osx-clone-then-optionally-remove">If you’re doing this on a Unix/Mac OSX clone then optionally remove</h1>
<p># the working tree and re-check everything out with the correct line endings.
git ls-files -z | xargs -0 rm
git checkout .
```</p>

<h2 id="gitattribute">gitattribute</h2>

<p><a href="https://help.github.com/articles/dealing-with-line-endings/">github上面的关于crlf的处理</a></p>

<p>其中一个重点，可以在<a href="https://help.github.com/articles/dealing-with-line-endings/#per-repository-settings">git库里面加入.gitattributes文件处理crlf的问题</a></p>

<p>例子:</p>

<p>```
# Set the default behavior, in case people don’t have core.autocrlf set.
* text=auto</p>

<h1 id="explicitly-declare-text-files-you-want-to-always-be-normalized-and-converted">Explicitly declare text files you want to always be normalized and converted</h1>
<p># to native line endings on checkout.
*.c text
*.h text</p>

<h1 id="declare-files-that-will-always-have-crlf-line-endings-on-checkout">Declare files that will always have CRLF line endings on checkout.</h1>
<p>*.sln text eol=crlf</p>

<h1 id="denote-all-files-that-are-truly-binary-and-should-not-be-modified">Denote all files that are truly binary and should not be modified.</h1>
<p>*.png binary
*.jpg binary
```</p>

<p>you’ll notice that files are matched–<code>*.c</code>, <code>*.sln</code>, <code>*.png</code>–, separated by a space, then given a setting–<code>text</code>, <code>text eol=crlf</code>, <code>binary</code>. We’ll go over some possible settings below.</p>

<p><code>text=auto</code></p>

<p>Git will handle the files in whatever way it thinks is best. This is a good default option.</p>

<p><code>text eol=crlf</code></p>

<p>Git will always convert line endings to CRLF on checkout. You should use this for files that must keep CRLF endings, even on OSX or Linux. For example, here is a Windows project that enforces CRLF line endings.</p>

<p><code>text eol=lf</code></p>

<p>Git will always convert line endings to LF on checkout. You should use this for files that must keep LF endings, even on Windows. For example, here is a project that enforces LF line endings.</p>

<p><code>binary</code></p>

<p>Git will understand that the files specified are not text, and it should not try to change them. The binary setting is also an alias for -text -diff.</p>

<p>另外一个是：
<a href="https://help.github.com/articles/dealing-with-line-endings/#refreshing-a-repository-after-changing-line-endings">Refreshing a repository after changing line endings</a></p>

<p>这部分和上面第一节是基本一样的内容，（前提是设置了core.autocrlf或.gitattributes文件)</p>

<h2 id="coreautocrlf">配置core.autocrlf</h2>
<p><a href="http://stackoverflow.com/questions/1967370/git-replacing-lf-with-crlf#20653073">core.autocrlf的解释</a></p>

<p>How core.autocrlf works:</p>

<p>```
core.autocrlf=true:    core.autocrlf=input:      core.autocrlf=false:</p>

<pre><code>   repo                     repo                    repo
/        \               /        \              /        \ crlf-&gt;lf    lf-&gt;crlf     crlf-&gt;lf       \          /            \        /              \        /                \      /                \
</code></pre>

<p>Reminder: crlf = win-style end-of-line marker, lf = unix-style.</p>

<p>Note that cr (mac-style) in not affected for any of three options above.
```</p>

<p>tips: 建议搭建使用编辑器的时候，如果是windows下，特别关注一下回车的格式
提交到代码仓库的时候，按照unix的格式提交。例如上面的<code>core.autocrlf=input</code>。
如果想在checkout的文件为crlf，就设置为<code>core.autocrlf=true</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git workflow]]></title>
    <link href="http://liuhongjiang.github.com/tech/blog/2015/05/20/git-workflow/"/>
    <updated>2015-05-20T14:49:00+08:00</updated>
    <id>http://liuhongjiang.github.com/tech/blog/2015/05/20/git-workflow</id>
    <content type="html"><![CDATA[<p>参考了网上的多篇文章，然后结合现在自己参与的项目，总结了一个关于项目的git workflow的流程。
基本上是参考了gitflow的这篇文章。<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>。</p>

<p>重点是下面这一张图片。</p>

<p><img class="center" src="http://nvie.com/img/git-model@2x.png"></p>

<h2 id="section">名词</h2>

<p>以上图片中的各个分支的解释。</p>

<ul>
  <li>
    <p>master分支</p>

    <p>master分支保存了最新的发布代码，是稳定分支。永久保存。</p>
  </li>
  <li>
    <p>develop分支</p>

    <p>保存了最新的下一个版本要发布的feature和bugfix的代码，是稳定分支，但是可以运行在一定时间内不稳定。永久保存。</p>

    <p>在没有创建release分支的时候，可以提交bugfix的代码（bug的fix version填写下一个版本的版本号）。一但创建了release分支，那么只能提交下一个版本的feature和bugfix代码。</p>
  </li>
</ul>

<!-- more -->

<ul>
  <li>
    <p>release分支</p>

    <p>在develop分支的上创建。它是当前要发布的版本的分支，只允许提交bugfix（bug的fix version填写当前版本和下一个版本），原则上不运行提交feature代码。完成测试以后，合并到master分支和develop分支。</p>

    <p>创建release分支后，当前版本要修复的bug，只需要提交到release分支。当release分支发布的时候，合并到master分支和develop分支后，在master分支上打上release的tag，删除release分支。</p>

    <p>命名规则：release/{version name} (version name是项目内部定义的项目名称，可以是版本号，例如v1.2.3，可以是发布日志rb_2015.03.19)</p>
  </li>
  <li>
    <p>feature分支</p>

    <p>新功能开发分支，从develop分支上创建，合并到develop分支。完成feature开发后，删除feature分支。</p>

    <p>命名规则：feature/xxxxxx (xxxxx为新特性描述，建议不要太长了, 例如add sticker)</p>
  </li>
  <li>
    <p>bug分支</p>

    <p>当没有release分支的时候，基于develop分支创建，合并到develop分支。删除bug分支。这时的fix version填下一个版本。</p>

    <p>当创建了release分支后：如果bug是需要在当前release版本的：基于release分支创建，合并到release分支中去。这时的fix version填当前版本和下一个版本。</p>

    <p>如果是下一个版本发布的：基于develop分支创建，合并到develop分支。这时的fix version填下一个版本。</p>

    <p>命名规则：bug/{issue-number}-xxxx ({issue-number}部分为issue号，例如MyProject-3555， xxxx部分为简单的说明，也可以省略，例如MyProject-3555-fix-deadlock)</p>
  </li>
  <li>
    <p>hotfix</p>

    <p>hotfix是当某一个版本发布到了真实环境中以后，发现了严重的bug，必要紧急修复的情况下，出现的版本。</p>

    <p>hotfix版本基于master分支上对应的release tag创建，合并到master分支和develop分支。如果hotfix的修复发布的时候，存在release分支，那么hotfix需要合并到release分支，而不是develop分支。</p>

    <p>hotfix分支合并以后，需要删除hotfix分支。</p>
  </li>
  <li>
    <p>maintenance分支</p>

    <p>由于在生产环境中，只有一个版本，所以不需要保留maintenance分支。</p>

    <p>如果生产环境中，有多个长期的维护版本，那么就需要保留这些版本对应的maintenance分支（有使用maint作为分支前缀）。当有bug在对应的维护分支上有bug的时候，需要基于这个维护分支创建bugfix分支， 完成修复后，需要将这个bugfix分支在合并回这个维护分支。</p>

    <p>如果其他对应维护分支也有同样的问题话，需要将这个bugfix的分支合并到那些对应的维护分支上去。并且如果在master和development分支上存在着相同的bug，也要将这个bugfix合并到master，development，如果还有release分支，也要合并到当前的release分支。</p>
  </li>
  <li>
    <p>release tag
  发布了release分支以后，将release合并到master分支，打上release tag，现在的命名规则：TC_2015.05.09.</p>
  </li>
</ul>

<h2 id="section-1">开发人员需要关注的</h2>

<p>平时开发feature的时候，从develop分支上拉feature分支，提pull request的时候，也是合并到develop中，feature命名的规则：命名规则：feature/xxxxxx (xxxxx为新特性描述，建议不要超过4个单词)</p>

<p>修复bug的时候，如果没有release分支，那么从develop上拉bug分支，合并到develop分支上。这时的fix version填下一个版本。</p>

<p>如果有release分支，那么从release分支上拉bug分支，合并到bug分支上。这时的fix version填当前版本和下一个版本。</p>

<p>如果有release分支，但是这个bug是下一个版本修复，那么就从从develop上拉bug分支，合并到develop分支上。这时的fix version填下一个版本。</p>

<p>bug分支的命名规则：bug/{issue-number}-xxxx ({issue-number}部分为issue号，例如MyProject-3555， xxxx部分为简单的说明，一两个单词就可以了，也可以省略)</p>

<h2 id="ci">CI</h2>

<p>CI需要在develop和release两个分支上构建。</p>

<h2 id="section-2">其他</h2>

<p>在合并分支时，如果希望保留合并的信息，建议使用<code>git merge --no-ff</code>, 不适用fast forward.</p>

<p>在发起pull request的时候，为了减少项目合并的管理者的负担，并且保证当前需要合并的分支，有一个比较干净的提交记录，使用<code>git rebase -i</code></p>

<h2 id="section-3">参考</h2>

<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>
<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow workflow</a>
<a href="http://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows">Distributed Git - Distributed Workflows</a>
<a href="http://git-scm.com/book/en/v2/Distributed-Git-Maintaining-a-Project">Distributed Git - Maintaining a Project</a></p>

<h2 id="gitflow-">gitflow 工具</h2>

<p><a href="https://github.com/nvie/gitflow">gitflow</a>
<a href="https://datasift.github.io/gitflow/TheHubFlowTools.html">hubflow</a>
<a href="http://danielkummer.github.io/git-flow-cheatsheet/">git-flow cheatsheet</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git tips]]></title>
    <link href="http://liuhongjiang.github.com/tech/blog/2015/05/09/git-tips/"/>
    <updated>2015-05-09T16:27:00+08:00</updated>
    <id>http://liuhongjiang.github.com/tech/blog/2015/05/09/git-tips</id>
    <content type="html"><![CDATA[<h2 id="how-to-pull-after-forced-update">how to pull after forced update</h2>

<p><code>
git reset origin/master --hard
</code></p>

<p>this willResets the index and working tree. Any changes to tracked files in the working tree since are discarded.</p>

<p>当前工作目录的index和本地修改，都会被丢弃（丢弃的修改包括已经提交到本地的commit)</p>

<!-- more -->

<p>可以使用 <code>--soft</code>
If you want to actually keep whatever changes you’ve got locally, do a <code>--soft</code> reset instead. which will update the commit history for the branch,
不会丢弃本地未提交的修改，但是会丢弃本地提交的修改。</p>

<p>另外还有两个参数 <code>--keep --merge</code>，我在本地试了一下，都报错了，没有深入了解。</p>

<h2 id="git-rebase">git rebase</h2>
<p>You can replay your local commits ontop of any other commit/branch using git rebase
例如你在feature分支，你可以基于master分支对当期的分支rebase</p>

<p><code>bash
git rebase -i origin/master
</code></p>

<p>this will invoke rebase in interactive mode where you can choose how to apply each individual commit that isn’t in the history you are rebasing on top of.</p>

<p>你也可以基于当期分支的之前的commit进行分子</p>

<p><code>bash
git rebase -i HEAD~3
</code></p>

<p>相对于从倒退3个提交，开始rebase，这样你就可以对的多次提交进行合并。</p>

<p>如果你的分支已经push到了远端，那么在rebase之后，你要push的话，只能用 forced git push。 </p>

<p><a href="http://stackoverflow.com/questions/9813816/git-pull-after-forced-update">git pull after forced update</a></p>

<h2 id="throw-away-local-commits-in-git">Throw away local commits in git</h2>

<p>前面讲到的git reset就可以完成这个工作。例如你在master分支上</p>

<p><code>bash
git reset --hard origin/master 
</code></p>

<p>这样就可以达到需要的效果。</p>

<p>不要使用git revert， git revert会提交一个新的commit去revert原来的commit，这样在history中就可以看到。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git reference]]></title>
    <link href="http://liuhongjiang.github.com/tech/blog/2015/05/09/git-reference/"/>
    <updated>2015-05-09T14:35:00+08:00</updated>
    <id>http://liuhongjiang.github.com/tech/blog/2015/05/09/git-reference</id>
    <content type="html"><![CDATA[<h2 id="git-ref">git ref</h2>

<p>可以使用下面的命令查看ref</p>

<p><code>bash
git show HEAD
</code></p>

<h2 id="head-vs-orighead">HEAD vs ORIG_HEAD</h2>
<p>HEAD is (direct or indirect, i.e. symbolic) reference to the current commit. It is a commit that you have checked in the working directory (unless you made some changes, or equivalent), and it is a commit on top of which “git commit” would make a new one. Usually HEAD is symbolic reference to some other named branch; this branch is currently checked out branch, or current branch. HEAD can also point directly to a commit; this state is called “detached HEAD”, and can be understood as being on unnamed, anonymous branch.</p>

<p><strong>ORIG_HEAD is previous state of HEAD, set by commands that have possibly dangerous behavior, to be easy to revert them.</strong> It is less useful now that Git has reflog: HEAD@{1} is roughly equivalent to ORIG_HEAD (HEAD@{1} is always last value of HEAD, ORIG_HEAD is last value of HEAD before dangerous operation).</p>

<p>“pull” or “merge” always leaves the original tip of the current branch in ORIG_HEAD.</p>

<p>HEAD is a moving pointer. Sometimes it means the current branch, sometimes it doesn’t.</p>

<!-- more -->

<p>So HEAD is NOT a synonym for “current branch” everywhere already.</p>

<p>HEAD means “current” everywhere in git, but it does not necessarily mean “current branch” (i.e. detached HEAD).</p>

<p>But it almost always means the “current commit”.
It is the commit “git commit” builds on top of, and “git diff –cached” and “git status” compare against.
It means the current branch only in very limited contexts (exactly when we want a branch name to operate on — resetting and growing the branch tip via commit/rebase/etc.).</p>

<p>http://stackoverflow.com/questions/964876/head-and-orig-head-in-git</p>

<h2 id="detached-head">detached head</h2>

<p>Detached head means you are no longer on a branch, you have checked out a single commit in the history (in this case the commit previous to HEAD, i.e. HEAD^).</p>

<p><a href="http://stackoverflow.com/questions/10228760/fix-a-git-detached-head">fix a git detached head</a></p>

<p>创建一个detach head，关注命令的输出</p>

<p>```bash
$git checkout head^
You are in ‘detached HEAD’ state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.</p>

<p>If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:</p>

<p>git checkout -b new_branch_name</p>

<p>HEAD is now at 635b2b1… Init the test.md file
```</p>

<h3 id="specifying-revision">specifying revision</h3>

<p>比较常用的</p>

<ul>
  <li>
    <p><code>&lt;sha1&gt;</code> </p>

    <p>dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</p>
  </li>
  <li>
    <p><code>&lt;refname&gt;</code>, e.g. master, heads/master, refs/heads/master</p>

    <p>If $GIT_DIR/<name> exists, that is what you mean (this is usually useful only for HEAD, FETCH_HEAD, ORIG_HEAD, MERGE_HEAD and CHERRY_PICK_HEAD);</name></p>
  </li>
  <li>
    <p><code>&lt;refname&gt;@{&lt;n&gt;}</code>, e.g. master@{1}</p>

    <p>从refname的最新的提交倒数n个提交。
  <code>@{&lt;n&gt;}, e.g. @{1}</code>， 当前的branch</p>
  </li>
  <li>
    <p><code>&lt;refname&gt;@{upstream}, e.g. master@{upstream}, @{u}</code></p>

    <p>ref的远端最新提交</p>
  </li>
  <li>
    <p><code>&lt;rev&gt;^, e.g. HEAD^, v1.5.1^0</code></p>

    <p>A suffix <code>^</code> to a revision parameter means the first parent of that commit object. </p>

    <p><code>^&lt;n&gt;</code> means the <code>&lt;n&gt;th</code> parent, <code>&lt;rev&gt;^</code> is equivalent to <code>&lt;rev&gt;^1</code>.</p>

    <p>As a special rule, <code>&lt;rev&gt;^0</code> means the commit itself.</p>

    <p>注意<code>head^2</code>的意思是head的第二个parent，不是parent的parent</p>

    <p><code>&lt;rev&gt;^^</code>的意思是第一个parent的第一个parent，等价于<code>&lt;rev&gt;^1^1</code></p>
  </li>
  <li>
    <p><code>&lt;rev&gt;~&lt;n&gt;, e.g. master~3</code></p>

    <p>A suffix <code>~&lt;n&gt;</code> to a revision parameter means the commit object that is the <n>th generation grand-parent of the named commit object, following only the first parents.</n></p>

    <p><code>&lt;rev&gt;~3</code> is equivalent to <code>&lt;rev&gt;^^^</code> which is equivalent to <code>&lt;rev&gt;^1^1^1</code>. </p>

    <p>注意，这一句“following only the first parents.”，这种方式只会追踪第一个parent。具体可以参考下面这个例子。</p>
  </li>
</ul>

<p>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.</p>

<p>```
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
    \ | /   |
     |/    |
      B     C
       \   /
        \ /
         A</p>

<p>A =      = A^0
B = A^   = A^1     = A~1
C = A^2  = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
```</p>

<p>以下是git的man page：
<a href="http://schacon.github.io/git/git-rev-parse#_specifying_revisions">specifying revisions</a>
or 
<a href="http://git-scm.com/docs/git-rev-parse#_specifying_revisions">specifying revisions</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git commit message convention]]></title>
    <link href="http://liuhongjiang.github.com/tech/blog/2015/04/30/git-commit-message-convention/"/>
    <updated>2015-04-30T08:58:00+08:00</updated>
    <id>http://liuhongjiang.github.com/tech/blog/2015/04/30/git-commit-message-convention</id>
    <content type="html"><![CDATA[<p>I collect all information for internet, I did not write a single word.</p>

<p>A well-crafted git commit message is the best way to communicate context about a change to fellow developers (and indeed to their future selves)</p>

<h2 id="examples">examples</h2>
<p>example of commit messages:</p>

<pre><code>Capitalized, short (50 chars or less) summary

More detailed explanatory text, if necessary.  Wrap it to about 72
characters or so.  In some contexts, the first line is treated as the
subject of an email and the rest of the text as the body.  The blank
line separating the summary from the body is critical (unless you omit
the body entirely); tools like rebase can get confused if you run the 
two together.
   
- Bullet points are okay, too
- Typically a hyphen or asterisk is used for the bullet, followed by a
  single space, with blank lines in between, but conventions vary here
- Use a hanging indent
</code></pre>

<!-- more -->
<p>Another one:</p>

<pre><code>Summarize changes in around 50 characters or less

More detailed explanatory text, if necessary. Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of the commit and the rest of the text as the body. The
blank line separating the summary from the body is critical (unless
you omit the body entirely); various tools like `log`, `shortlog`
and `rebase` can get confused if you run the two together.

Explain the problem that this commit is solving. Focus on why you
are making this change as opposed to how (the code explains that).
Are there side effects or other unintuitive consequenses of this
change? Here's the place to explain them.

Further paragraphs come after blank lines.

- Bullet points are okay, too

- Typically a hyphen or asterisk is used for the bullet, preceded
  by a single space, with blank lines in between, but conventions
  vary here

If you use an issue tracker, put references to them at the bottom,
like this:

Resolves: #123
See also: #456, #789
</code></pre>

<h2 id="subject">subject</h2>
<ul>
  <li>Separate subject from body with a blank line</li>
  <li>Limit the subject line to 50 characters</li>
  <li>Capitalize the subject line</li>
  <li>Do not end the subject line with a period</li>
  <li>Use the imperative mood in the subject line: “Fix bug” and not “Fixed bug” or “Fixes bug.”</li>
  <li>The subject should be a concise summary of the changes introduced by the commit</li>
</ul>

<h2 id="body">body</h2>
<ul>
  <li>Wrap the body at 72 characters</li>
  <li>Use the body to explain what and why vs. how</li>
  <li>Try to answer the following questions in your commit message
    <ul>
      <li>Why is this change necessary?</li>
      <li>How does it address the issue?</li>
      <li>What side effects does this change have?</li>
    </ul>
  </li>
</ul>

<h2 id="others">others</h2>
<ul>
  <li>Never use the <code>-m &lt;msg&gt;</code> or <code>--message=&lt;msg&gt;</code> flag to git commit</li>
  <li>The Linux kernel and git itself are great examples</li>
</ul>

<h2 id="reference">reference</h2>
<p>These are the article I got above good practice of git commit messages. Read it carefully.</p>

<ul>
  <li><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">A Note About Git Commit Messages</a></li>
  <li><a href="https://robots.thoughtbot.com/5-useful-tips-for-a-better-commit-message">5 Useful Tips For A Better Commit Message</a></li>
  <li><a href="http://chris.beams.io/posts/git-commit/">How to Write a Git Commit Message</a></li>
  <li><a href="https://github.com/torvalds/linux/pull/17#issuecomment-5659933">real stickler for a good commit message, Linus Torvalds</a></li>
  <li><a href="https://github.com/blog/926-shiny-new-commit-styles">Shiny new commit styles</a></li>
</ul>

<h2 id="git-commit-message-line-wrapping-in-idea">git commit message line wrapping in IDEA</h2>
<p><a href="https://youtrack.jetbrains.com/issue/IDEA-53615#comment=27-446912">git commit message line wrapping</a></p>

<p>if you turn on the line margin in the commit dialog in the Setting | Version Control, commit dialog text area becomes monospaced. 
Moreover, if you turn on “Wrap when typing reaches right margin” in Settings | Code style | General, it will affect the commit dialog text area as well (however, it will affect the main editor too).</p>

<p>A separate setting to wrap when text reaches right margin has been added to Settings | Version Control.</p>

]]></content>
  </entry>
  
</feed>
